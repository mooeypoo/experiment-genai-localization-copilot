# Agent Notes 10

## 1) Summary
- Implemented locale-aware user sorting throughout the application.
- Users now sort alphabetically according to the currently selected language's collation rules.
- Added computed properties in UserList and ViewingAsSelector components using Intl.Collator API.
- Sorting updates reactively when language changes—no manual refresh needed.
- Supports all 7 languages with proper alphabetical ordering specific to each locale.
- No new dependencies required—uses native JavaScript Internationalization API.

## 2) Decisions & Rationale

**API Choice: Intl.Collator**
Used the JavaScript Internationalization API's Intl.Collator for locale-aware string comparison:
- Native browser API, no external dependencies
- Supports all locales we're using (en, fr, es, he, ar, fa, zh-CN)
- Handles complex sorting rules automatically (accents, diacritics, stroke order)
- Performant—creates reusable collator object for comparisons
- Standard approach for internationalized applications

Alternative considered: Manual sorting logic per language (rejected—error-prone, unmaintainable, incomplete).

**Collator Configuration Options**
Used specific options for the Intl.Collator:
```javascript
new Intl.Collator(locale.value, {
  sensitivity: 'base',
  numeric: true
})
```

**sensitivity: 'base'**
- Ignores case and diacritical marks for comparison
- "A" and "a" are treated the same
- "e" and "é" are treated the same
- Focuses on base letter differences only
- More intuitive for user name sorting (case-insensitive)

Alternative options:
- 'accent': Would distinguish é from e (rejected—too strict for names)
- 'case': Would distinguish A from a but not é from e (rejected—inconsistent)
- 'variant': Most strict, distinguishes everything (rejected—unnecessary for names)

**numeric: true**
- Sorts numbers naturally (e.g., "User 2" before "User 10")
- Without this: "User 10" < "User 2" (lexicographic)
- With this: "User 2" < "User 10" (natural number order)
- Useful if usernames contain numbers (e.g., "Amir 2", "Amir 10")

This prevents confusing sort orders when names include version numbers or sequences.

**Implementation Location: Component-Level Computed Properties**
Implemented sorting in the components (UserList, ViewingAsSelector) rather than in the store:
- Sorting depends on UI state (current locale)
- Components have access to locale via useI18n()
- Reactive—automatically re-sorts when locale changes
- Keeps data layer (store) locale-agnostic

Alternative considered: Sort in store.js getUsers() (rejected—store shouldn't know about UI locale preference).

**Reactive Sorting via Computed Properties**
Used Vue computed properties for automatic reactivity:
```javascript
const sortedUsers = computed(() => {
  const collator = new Intl.Collator(locale.value, ...)
  return [...props.users].sort((a, b) => collator.compare(a.name, b.name))
})
```

- `locale.value` is a reactive dependency
- When locale changes, computed property recalculates automatically
- Users instantly see re-sorted list without manual refresh
- Efficient—only recomputes when locale or users array changes

**Array Spreading for Immutability**
Used `[...props.users].sort()` instead of `props.users.sort()`:
- Array.prototype.sort() mutates the array in-place
- Mutating props directly violates Vue's one-way data flow
- Spreading creates a shallow copy before sorting
- Original users array remains unchanged
- Prevents unexpected side effects in parent components

**Sort Key: User Name**
Sorting by `user.name` (display name) rather than handle or ID:
- Display names are what users see and recognize
- Alphabetical order by name is intuitive and expected
- Handles contain special characters (@) that complicate sorting
- IDs are opaque identifiers not meaningful to users

**Language-Specific Sorting Behavior**

**English (en):**
- Standard A-Z alphabetical order
- Case-insensitive (Amir, Diego, Lina, Mara, Noa, Ravi, Yasmin, Zara)

**French (fr):**
- Accented characters sorted with their base letters
- á, à, â treated as variants of 'a'
- ç treated as variant of 'c'
- No French names in our seed data, but system supports it

**Spanish (es):**
- Similar to French with accent handling
- ñ historically sorted after 'n', before 'o' (in traditional Spanish)
- Modern sorting often treats ñ as n variant (our 'base' sensitivity does this)
- No Spanish names in seed, but ready for them

**Hebrew (he):**
- Aleph-bet order: א ב ג ד (aleph, bet, gimel, dalet)
- Right-to-left script but sorted left-to-right in arrays
- Noa (נועה) would sort according to Hebrew character order
- Final letter forms (ך, ם, ן, ף, ץ) treated as variants
- Our seed has "Noa Mizrahi" in Latin script—sorts as English

**Arabic (ar):**
- Arabic alphabet order: ا ب ت ث ج (alif, ba, ta, tha, jim)
- Right-to-left script
- Amir (أمير / عامر) would follow Arabic collation
- Diacritical marks (harakat) ignored with sensitivity: 'base'
- Seed has "Amir Khalil" in Latin—sorts as English

**Farsi (fa):**
- Similar to Arabic with additional letters (پ چ ژ گ)
- Persian alphabet extends Arabic alphabet
- Yasmin (یاسمین) would follow Persian order
- Seed has "Yasmin Behnam" in Latin—sorts as English

**Chinese (zh-CN):**
- Simplified Chinese sorting is complex:
  - Option 1: By Pinyin romanization (alphabetical of pronunciation)
  - Option 2: By stroke count (number of strokes in character)
  - Option 3: By radical (semantic component)
- Intl.Collator for zh-CN typically uses Pinyin (most common)
- Browser determines exact algorithm
- No Chinese names in seed data (all Latin script)

**Current Seed Data Reality:**
All user names in seed.json are written in Latin script:
- Mara Ortiz, Ravi Sen, Lina Park, Diego Costa
- Yasmin Behnam, Amir Khalil, Noa Mizrahi, Zara Kapoor

Even though names have Persian, Arabic, Hebrew origins, they're romanized. Therefore:
- English locale: A D L M N R Y Z (alphabetical)
- All locales currently sort identically because all names are Latin script
- If native-script names were added, sorting would differ by locale

**Performance Considerations**
Creating Intl.Collator in computed property on every recomputation:
- Collator creation is relatively fast (microseconds)
- Computed property only recalculates when dependencies change
- Alternative: Create once and cache (more complex, marginal benefit)
- Current approach balances simplicity and performance

For 8 users, sorting is instantaneous. For 1000+ users, might need optimization.

**Stability of Sort**
JavaScript's Array.sort() is stable (since ES2019):
- Elements with equal sort keys maintain their original relative order
- If two users have the same name, they'll stay in their original order
- Predictable, consistent behavior

**Default User Selection Unchanged**
ViewingAsSelector still defaults to first user in the original array:
```javascript
if (!viewingUserId.value && next.length) {
  setViewingUser(next[0].id)
}
```

This defaults to u1 (Mara Ortiz) regardless of sorting. Considered changing to first alphabetically, but decided:
- Preserves existing behavior (u1 is the default viewing user)
- Avoids confusion when language changes (default wouldn't change)
- Explicit default is more predictable than alphabetical first

**No Visual Sort Indicator**
Didn't add UI element showing "Sorted by: Name (A-Z)":
- Alphabetical sorting is expected default behavior
- Users understand lists are alphabetized without explicit indication
- Keeps UI clean and uncluttered
- Could add if user feedback indicates confusion

**No Alternative Sort Options**
Not providing UI to sort by:
- Join date (not tracked)
- Activity (no activity metrics)
- Handle (@username)
- Pronouns

Alphabetical by name is the universal, expected default for user lists.

## 3) Ambiguities Encountered

**Should we sort in the store or in components?**
- Options considered:
  - (a) Sort in store.js getUsers() function
  - (b) Sort in components with computed properties
  - (c) Sort in parent view (UsersView) before passing to children
- Resolution: Sort in components (option b)
- Rationale: Locale is UI state accessed via useI18n(); components have direct access to locale; reactive computed properties handle locale changes automatically; keeps store agnostic of UI preferences.

**Which Intl.Collator sensitivity to use?**
- Options considered:
  - (a) 'base' - ignore case and accents
  - (b) 'accent' - ignore case, consider accents
  - (c) 'case' - consider case, ignore accents
  - (d) 'variant' - consider everything
- Resolution: 'base' (option a)
- Rationale: Case-insensitive is standard for name sorting; treating accented variants together makes sense (José and Jose should be adjacent); more intuitive for multilingual names; matches user expectations from other apps.

**Should we handle Chinese names differently?**
- Options considered:
  - (a) Use Pinyin-based sorting for Chinese locale
  - (b) Detect Chinese characters in names and apply special sorting
  - (c) Rely on browser's Intl.Collator default behavior
- Resolution: Rely on browser default (option c)
- Challenge: Chinese collation varies (Pinyin vs stroke count vs radical)
- Rationale: Browser's Intl.Collator for zh-CN handles this automatically; typically uses Pinyin (most common); no Chinese-script names in current seed data; when added, browser handles it correctly.

**Should sorted order change when language changes?**
- Options considered:
  - (a) Re-sort when locale changes (current implementation)
  - (b) Lock sort order to original English alphabetical
  - (c) Let user choose whether to re-sort on language change
- Resolution: Automatic re-sort (option a)
- Rationale: Most intuitive—users expect their selected language's alphabetical order; computed property makes this trivial; no performance impact; consistent with i18n best practices.

**Should we sort ViewingAsSelector dropdown?**
- Options considered:
  - (a) Sort dropdown same as user list
  - (b) Keep dropdown in original order (ID order from seed data)
  - (c) Sort dropdown but not user list
- Resolution: Sort both consistently (option a)
- Rationale: Consistency across all user displays; alphabetical order helps find users quickly in dropdown; same behavior everywhere reduces cognitive load.

**What should be the default sort direction?**
- Options considered:
  - (a) Ascending (A-Z) alphabetical
  - (b) Descending (Z-A)
  - (c) User preference / toggleable
- Resolution: Ascending (option a)
- Rationale: Standard convention for directories and contact lists; expected default; no UI to toggle direction, so ascending is universal choice.

**Should we create Intl.Collator once or per-computation?**
- Options considered:
  - (a) Create new collator in computed property each time
  - (b) Cache collator and recreate when locale changes
  - (c) Use memoization
- Resolution: Create per-computation (option a)
- Rationale: Computed property already caches the sorted result; collator creation is fast; simpler code without memoization; marginal performance difference for small user lists.

**Should we sort by firstName + lastName separately?**
- Options considered:
  - (a) Sort by full display name string (current)
  - (b) Parse into first/last and sort by last name first
  - (c) Add separate firstName/lastName fields
- Resolution: Sort by full name string (option a)
- Challenge: Names don't follow universal firstname-lastname pattern; parsing is unreliable
- Rationale: "Ravi Sen" vs "Lina Park"—no universal rule; full name string sorting is unambiguous; works for all name formats (mononyms, multiple parts, etc.).

**Should numbers in names sort naturally?**
- Options considered:
  - (a) Enable numeric: true (current)
  - (b) Disable numeric sorting
  - (c) Only enable for specific locales
- Resolution: Enable globally (option a)
- Rationale: Natural number sorting (User 2 < User 10) is almost always desired; no downside to enabling; handles edge cases better; generic enough for all locales.

## 4) Tradeoffs

**Component-Level Sorting vs Store-Level:**
- Chose component-level computed properties
- Tradeoff: Sorting logic duplicated in two components (UserList, ViewingAsSelector)
- Benefit: Components have direct access to locale, reactive updates automatic, store remains locale-agnostic

**Automatic Re-sort on Language Change:**
- Users re-sort when switching languages
- Tradeoff: User's visual position in list might change when switching language
- Benefit: Alphabetical order always matches current language expectations, more intuitive for multilingual users

**sensitivity: 'base' vs stricter options:**
- Ignored case and accents
- Tradeoff: José Ortiz and Jose Ortiz would group together (might be desired separation)
- Benefit: More flexible, case-insensitive is expected, groups similar names together

**Sorting by Display Name vs Handle:**
- Sorted by visible display name
- Tradeoff: Handles might be more unique identifiers for sorting
- Benefit: Display names are what users see and recognize, more intuitive

**Creating Collator in Computed vs Caching:**
- Create new collator on each computed execution
- Tradeoff: Slight overhead of collator creation (microseconds)
- Benefit: Simpler code, no state management for cached collator, negligible performance cost

**No Sort Direction Toggle:**
- Always ascending (A-Z)
- Tradeoff: Users can't reverse to Z-A if desired
- Benefit: Simpler UI, ascending is universal default, no additional UI clutter

**No Visual Sort Indicator:**
- No UI showing "Sorted by Name (A-Z)"
- Tradeoff: Users don't explicitly see sort criteria
- Benefit: Cleaner UI, alphabetical is expected default

## 5) Non-Goals

- Descending (Z-A) sort order option
- UI toggle to switch between sort criteria (by name, by handle, by date)
- Sort direction persistence (remembering user's preference)
- Multi-column sorting or secondary sort keys
- Custom user-defined sort order
- Drag-and-drop manual reordering
- Filtering or search within sorted lists
- Grouping users by first letter (A, B, C headers)
- Sort animation when language changes
- Server-side sorting (all client-side)
- Preserving scroll position on re-sort
- Locale-specific sort algorithms beyond Intl.Collator defaults
- Separate sort orders for grid vs dropdown
- Performance optimization for large user lists (not needed for 8 users)
- Sort caching or memoization (computed property already handles this)
- Unit tests for sorting behavior (could be added later)

## 6) Files Changed
- Updated: [src/components/UserList.vue](../../src/components/UserList.vue) - Added sortedUsers computed property with Intl.Collator
- Updated: [src/components/ViewingAsSelector.vue](../../src/components/ViewingAsSelector.vue) - Added sortedUsers computed property
- Added: [docs/agent-notes/10.md](10.md)

No changes to CSS, store, or other components required.

## 7) Manual Verification Checklist
- Run `npm run dev` and verify app loads without errors.
- Open Users page in English—verify users sorted A-Z: Amir, Diego, Lina, Mara, Noa, Ravi, Yasmin, Zara.
- Switch to French (Français)—verify users still sorted alphabetically (same order since names are Latin).
- Switch to Spanish (Español)—verify alphabetical order maintained.
- Switch to Hebrew (עברית)—confirm users still sort by Latin names (A-Z).
- Switch to Arabic (العربية)—verify sort order (Latin names sort as Latin alphabet).
- Switch to Farsi (فارسی)—confirm alphabetical Latin sorting.
- Switch to Simplified Chinese (简体中文)—verify users sort correctly (Latin names).
- Check "Viewing as" dropdown in header—verify users listed alphabetically there too.
- Create a new user named "Alex Test"—verify they appear at the beginning alphabetically.
- Create another user "Zoe Test"—verify they appear at the end.
- Switch languages with new users—confirm they stay in alphabetical order for each locale.
- Test with uppercase/lowercase: Create "bob smith"—verify sorts with Bob/BOB (case-insensitive).
- Check browser console—no errors or warnings about Intl or sorting.
- Verify user grid reflows correctly as users re-sort when changing language.
- Test on mobile (720px breakpoint)—confirm sorted users display correctly.
- Refresh page and verify sorted order persists based on selected language.
- Check ViewingAsSelector dropdown order matches UserList grid order.
- Verify changing language causes dropdown to re-sort visually.
- Create user with numbers: "User 2", "User 10", "User 1"—verify natural sort: User 1, User 2, User 10.

## 8) Known Issues / Follow-ups

**All Names Currently in Latin Script:**
- Seed data uses Latin script for all names (Mara, Ravi, etc.)
- Locale-aware sorting currently has same result for all languages
- Would see different orders if Hebrew (נועה), Arabic (أمير), or Chinese (李明) names added
- Could enhance seed data with native-script names to demonstrate true locale sorting

**No Mixed-Script Name Handling:**
- If a user has "李明 (Li Ming)" with both Chinese and Latin, sorting might be unpredictable
- Intl.Collator handles mixed scripts but behavior varies by browser
- Generally not an issue in practice—users pick one script per name

**Sort Direction Not Configurable:**
- Always ascending (A-Z)
- No UI to toggle to descending (Z-A)
- Could add sort direction toggle if user requests it

**No Sort Persistence:**
- Sort criteria (by name) and direction not saved to localStorage
- Not needed currently since there's only one sort option
- Would become relevant if multiple sort criteria added

**Chinese Pinyin vs Stroke Count:**
- Browser's zh-CN collation typically uses Pinyin
- Some users in Taiwan might expect stroke count or Traditional Chinese order
- No control over which algorithm Intl.Collator uses for Chinese
- Usually not an issue—Pinyin is most common modern standard

**Performance with Large User Lists:**
- Currently 8 users—sorting is instantaneous
- With 1000+ users, computed property might recalculate frequently
- Could optimize with virtualized lists or pagination if needed
- Not a concern for current demo scale

**No Visual Feedback on Sort Change:**
- When language changes, list re-sorts silently
- No animation or transition showing the re-sort
- Could add subtle transition if user feedback indicates confusion
- Generally, instant re-sort is fine for small lists

**Collator Creation in Computed:**
- Creating new Intl.Collator on each computed execution
- Technically could cache and recreate only when locale changes
- Performance gain would be negligible for 8 users
- Simplicity outweighs marginal optimization

**No Secondary Sort Key:**
- Only sorting by name
- If two users have identical names, order is based on original array order (stable sort)
- Could add secondary sort by handle or ID for deterministic ordering
- Unlikely issue in practice—names are usually unique

**Dropdown Default User Unchanged:**
- ViewingAsSelector defaults to u1 (Mara) in original array
- Doesn't default to first alphabetically sorted user
- This preserves consistent default across language changes
- Could be confusing if user expects first alphabetical

**No User Grouping:**
- Could group users by first letter (A, B, C, etc.) with section headers
- Common in contact lists for easier navigation
- Not implemented—current 8 users don't need grouping
- Would be useful if user count grows significantly

**Sort Doesn't Account for Nicknames:**
- Sorting by display name only
- If user's display name is a nickname, might not sort where expected
- Example: "DJ" would sort under D, not J in English
- Acceptable—users control their display names

**No Search Integration:**
- Sorting works but there's no search/filter feature
- Users must scroll to find specific user in sorted list
- Fine for 8 users; would need search for 50+
- Could add search in future iteration

**No Sort Announcement for Accessibility:**
- Screen readers aren't notified when list re-sorts on language change
- Could add aria-live region announcing "Users sorted by name"
- Generally, sorted list read in new order is sufficient
- Would improve if adding sort direction toggle

**Locale Fallback on Invalid Locale:**
- If somehow invalid locale is passed to Intl.Collator, it would throw
- No explicit error handling currently
- Unlikely in practice since locale comes from vue-i18n valid options
- Could add try-catch for robustness

**Browser Compatibility:**
- Intl.Collator is well-supported (IE11+, all modern browsers)
- Specific locale support varies (some browsers might fall back to default locale)
- Generally not an issue—target browsers all support our locales
- Could add polyfill for older environments

**No Customization Per Locale:**
- Using same collator options for all locales
- Some locales might benefit from different sensitivity settings
- Example: German traditionally differentiates ß from ss, but we treat them same
- Current approach is generic and works well for most cases

**Numerical Sorting Edge Cases:**
- numeric: true handles "User 2" < "User 10"
- Might behave unexpectedly with fractional numbers or negative numbers
- Example: "User -5" might sort oddly
- Not expected in user names, so acceptable

**No Integration with User Activity:**
- Sorting is purely alphabetical, doesn't consider:
  - Last active time
  - Number of posts/comments
  - Reputation or engagement
- These metrics aren't tracked in current app
- Alphabetical is universal default for user directories

